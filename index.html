<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Libro para Colorear con Realidad Aumentada</title>
    <!-- Favicon -->
    <link rel="icon" href="https://raw.githubusercontent.com/instructorandradedcc/propuesta-AR/main/favicon3dAR.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
            }
        }
    </script>
    <style>
        html.ar-active, body.ar-active { overflow: hidden; width: 100%; height: 100%; margin: 0; padding: 0; }
        #app { transition: all 0.3s ease-in-out; }
        .app-container.ar-fullscreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; max-height: none; padding: 0; margin: 0 !important; border-radius: 0; overflow: hidden; }
        .page { display: none; }
        .page.active { display: block; }
        #ar-scene-container.ar-active { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9990; }
        #ar-scene-container.ar-active a-scene { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #ar-scene-container.ar-active video, 
        #ar-scene-container.ar-active canvas { position: absolute !important; top: 50% !important; left: 50% !important; transform: translate(-50%, -50%) !important; min-width: 100% !important; min-height: 100% !important; width: auto !important; height: auto !important; object-fit: cover !important; cursor: grab; }
        #ar-active-controls { position: fixed; bottom: 0; left: 0; width: 100%; z-index: 9999; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #scanning-ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9991; display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: none; background-color: rgba(0,0,0,0.3); transition: opacity 0.3s; }
        #scanning-ui.hidden { display: none; }
        .scan-text { margin-top: 24px; padding: 8px 16px; background-color: rgba(0,0,0,0.5); color: white; font-size: 1.1rem; border-radius: 8px; text-shadow: 1px 1px 2px black; }
    </style>
</head>
<body class="bg-gray-200 text-gray-800 font-sans">
    
    <div id="app" class="app-container container mx-auto p-6 md:p-8 max-w-5xl bg-white rounded-xl shadow-lg my-8 overflow-y-auto" style="max-height: 85vh;">
        <div class="flex justify-center items-center mb-6">
             <img src="https://raw.githubusercontent.com/instructorandradedcc/propuesta-AR/main/logofundacion.jpg" alt="Logo" class="h-20 w-auto mr-4" onerror="this.onerror=null;this.src='https://placehold.co/120x80/e2e8f0/94a3b8?text=Logo';">
             <div>
                 <h1 class="text-3xl md:text-4xl font-bold text-center" style="color: #1e3a8a;">
                     Libro para Colorear con Realidad Aumentada
                     <span id="app-version" class="text-base align-middle font-normal text-gray-400 ml-2"></span>
                 </h1>
                 <p class="text-center text-gray-500">Colorea el dibujo y mira cómo cobra vida.</p>
             </div>
        </div>

        <!-- PÁGINA 1: Carga de Recursos -->
        <div id="page-loader" class="page active bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Paso 1: Cargar Recursos</h2>
            <div class="bg-indigo-50 border-l-4 border-indigo-500 text-indigo-700 p-4 mb-6" role="alert">
                <p class="font-bold">¡Bienvenido!</p>
                <p id="loader-welcome-text">Presiona el botón para descargar los recursos. Los archivos se guardarán en la caché de tu navegador para acelerar futuras cargas.</p>
            </div>                               
            <div class="mt-6 flex flex-col sm:flex-row justify-center items-center gap-4">
                <button id="load-assets-btn" class="bg-green-500 text-white font-bold py-3 px-6 rounded-lg hover:bg-green-600 transition duration-300 text-lg shadow-md w-full sm:w-auto flex justify-center items-center">
                    Cargar Recursos
                </button>
                <button id="clear-cache-btn" class="bg-red-500 text-white font-bold py-3 px-6 rounded-lg hover:bg-red-600 transition duration-300 text-lg shadow-md w-full sm:w-auto flex justify-center items-center">
                    Limpiar Caché
                </button>
            </div>
            <div id="loading-status" class="mt-6 hidden">
                <div class="flex justify-center items-center"><div class="loader"></div></div>
                <p id="loading-text" class="text-center text-gray-600 mt-2">Iniciando...</p>
                <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                    <div id="loading-progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- PÁGINA 2: Iniciar AR -->
        <div id="page-ar" class="page">
             <div class="relative">
                 <div id="ar-ui-container" class="relative z-10">
                     <h2 class="text-2xl font-semibold mb-2 text-center">Paso 2: Prepara tu dibujo</h2>
                     <p class="text-center text-gray-600 mb-4">Usa esta imagen para colorear. Luego, presiona "Iniciar AR".</p>
                     <div id="marker-preview-container" class="mb-4 bg-gray-100 p-4 rounded-lg flex justify-center items-center min-h-[200px]">
                         <img id="marker-image" class="max-w-full max-h-64 h-auto rounded shadow-md hidden" alt="Imagen del marcador para colorear">
                     </div>
                      <div class="mt-6 flex justify-center items-center gap-4">
                          <button id="start-ar-btn" class="bg-green-500 text-white font-bold py-3 px-6 rounded-lg hover:bg-green-600 transition duration-300 text-lg shadow-md flex items-center justify-center gap-2">
                              <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path><circle cx="12" cy="13" r="3"></circle></svg>
                              Iniciar AR
                          </button>
                      </div>
                 </div>
                 <div id="ar-scene-container"></div>
                 <div id="scanning-ui" class="hidden"><p class="scan-text">Apunte al marcador de la página</p></div>
                 <div id="ar-active-controls" class="hidden p-4 bg-black bg-opacity-50">
                      <div class="relative flex justify-center items-center gap-4 max-w-4xl mx-auto">
                          <button id="stop-ar-btn" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600 transition duration-300">Detener Cámara</button>
                      </div>
                 </div>
             </div>
        </div>
    </div>

    <div id="ar-preloader" class="hidden fixed inset-0 bg-black bg-opacity-75 flex flex-col justify-center items-center z-[10000]">
        <div class="loader"></div>
        <p id="preloader-text" class="text-white text-lg mt-4">Iniciando cámara...</p>
    </div>

    <script type="module">
    import * as THREE from 'three';
    
    AFRAME.registerComponent('texture-from-video', {
        schema: {},
        init: function () {
            this.sceneEl = this.el.sceneEl; this.model = null; this.textureCanvas = null; this.textureContext = null; this.texture = null; this.video = null; this.logged = false;
            this.el.addEventListener('model-loaded', () => { this.model = this.el.getObject3D('mesh'); this.setupTexture(); });
            this.sceneEl.addEventListener('arReady', () => { this.video = document.querySelector('video'); });
        },
        setupTexture: function() {
            if (!this.model) return;
            this.textureCanvas = document.createElement('canvas'); this.textureCanvas.width = 512; this.textureCanvas.height = 512;
            this.textureContext = this.textureCanvas.getContext('2d');
            this.texture = new THREE.CanvasTexture(this.textureCanvas);
            this.texture.minFilter = THREE.LinearFilter; this.texture.magFilter = THREE.LinearFilter; this.texture.colorSpace = THREE.SRGBColorSpace;
            this.model.traverse((node) => { if (node.isMesh && node.material) { node.material = node.material.clone(); node.material.map = this.texture; node.material.needsUpdate = true; } });
        },
        tick: function() {
            const mindarSystem = this.el.sceneEl.systems['mindar-image-system'];
            if (this.video && this.textureContext && mindarSystem && mindarSystem.controller && this.el.object3D.visible) {
                try {
                    const markerCorners = mindarSystem.controller.getMarkerWorldCorners(0);
                    if (markerCorners) {
                        this.textureContext.clearRect(0, 0, this.textureCanvas.width, this.textureCanvas.height);
                        const screenCoords = markerCorners.map(corner => {
                            const vector = new THREE.Vector3(corner.x, corner.y, corner.z).project(this.el.sceneEl.camera);
                            return { x: (vector.x + 1) * this.video.videoWidth / 2, y: (-vector.y + 1) * this.video.videoHeight / 2 };
                        });
                        this.drawPerspectiveCorrectedImage(screenCoords);
                        this.texture.needsUpdate = true;
                    }
                } catch(e) { if (!this.logged) { console.error("Error al proyectar la textura:", e); this.logged = true; } }
            }
        },
        drawPerspectiveCorrectedImage: function(points) {
            const ctx = this.textureContext, canvas = this.textureCanvas;
            const to = [{ x: 0, y: 0 }, { x: canvas.width, y: 0 }, { x: canvas.width, y: canvas.height }, { x: 0, y: canvas.height }];
            ctx.save(); ctx.beginPath(); ctx.moveTo(to[0].x, to[0].y); ctx.lineTo(to[1].x, to[1].y); ctx.lineTo(to[2].x, to[2].y); ctx.lineTo(to[3].x, to[3].y); ctx.closePath(); ctx.clip();
            this.drawTriangle(points[0], points[1], points[3], to[0], to[1], to[3]);
            this.drawTriangle(points[1], points[2], points[3], to[1], to[2], to[3]);
            ctx.restore();
        },
        drawTriangle: function(p0, p1, p2, t0, t1, t2) {
            const ctx = this.textureContext, video = this.video;
            ctx.beginPath(); ctx.moveTo(t0.x, t0.y); ctx.lineTo(t1.x, t1.y); ctx.lineTo(t2.x, t2.y); ctx.closePath(); ctx.clip();
            const det = p1.x * p2.y + p0.x * p1.y + p2.x * p0.y - p1.x * p0.y - p2.x * p1.y - p0.x * p2.y;
            const a = (p2.y * t0.x - p0.y * t2.x + (p0.y - p2.y) * t1.x) / det, b = (p2.x * t0.x - p0.x * t2.x + (p0.x - p2.x) * t1.x) / det, c = t0.x - a * p0.x - b * p0.y;
            const d = (p2.y * t0.y - p0.y * t2.y + (p0.y - p2.y) * t1.y) / det, e = (p2.x * t0.y - p0.x * t2.y + (p0.x - p2.x) * t1.y) / det, f = t0.y - d * p0.x - e * p0.y;
            ctx.transform(a, d, b, e, c, f); ctx.drawImage(video, 0, 0);
        }
    });

    AFRAME.registerComponent('ar-rotator', {
        schema: { rotationFactor: { type: 'number', default: 1 } },
        init: function () {
            this.isVisible = false; this.isDragging = false; this.previousDrag = { x: 0, y: 0 }; const canvas = this.el.sceneEl.canvas;
            const startDrag = (x, y) => { if (this.isVisible) { this.isDragging = true; this.previousDrag = { x, y }; } };
            const drag = (x, y) => { if (this.isDragging && this.isVisible) { const deltaX = x - this.previousDrag.x; const deltaY = y - this.previousDrag.y; this.el.object3D.rotation.y += THREE.MathUtils.degToRad(deltaX * this.data.rotationFactor); this.el.object3D.rotation.x += THREE.MathUtils.degToRad(deltaY * this.data.rotationFactor); this.previousDrag = { x, y }; } };
            const endDrag = () => { this.isDragging = false; };
            canvas.addEventListener('touchstart', (e) => { if (e.touches.length === 1) startDrag(e.touches[0].clientX, e.touches[0].clientY); }); canvas.addEventListener('touchmove', (e) => { if (e.touches.length === 1) drag(e.touches[0].clientX, e.touches[0].clientY); }); canvas.addEventListener('touchend', endDrag); canvas.addEventListener('mousedown', (e) => startDrag(e.clientX, e.clientY)); canvas.addEventListener('mousemove', (e) => drag(e.clientX, e.clientY)); canvas.addEventListener('mouseup', endDrag); canvas.addEventListener('mouseleave', endDrag);
            this.el.parentEl.addEventListener('targetFound', () => { this.isVisible = true; }); this.el.parentEl.addEventListener('targetLost', () => { this.isVisible = false; });
        },
    });

    document.addEventListener('DOMContentLoaded', () => {
        const APP_VERSION = 'v2.9'; // Updated version
        const CACHE_NAME = `ar-color-cache-${APP_VERSION}`;
        document.getElementById('app-version').textContent = APP_VERSION;

        const state = { isArActive: false, assets: {} };
        // SOLUCIÓN DEFINITIVA: Cambiar a un CDN alternativo (Statically) que no tenga problemas de caché de permisos.
        const GITHUB_BASE_URL = 'https://cdn.statically.io/gh/instructorandradedcc/propuesta-AR/main/asetss/';

        const ASSET_MAPPING = [{
            name: 'cabeza1',
            markerFile: 'mano-iz-protesis.mind',
            modelFile: 'cabeza1.glb',
            imageFile: 'cabeza1.png'
        }];

        const pages = {
            loader: document.getElementById('page-loader'),
            ar: document.getElementById('page-ar')
        };

        function navigateTo(pageId) {
            Object.values(pages).forEach(p => p.classList.remove('active'));
            if(pages[pageId]) pages[pageId].classList.add('active');
        }
        
        function getAssetUrls() {
            const asset = ASSET_MAPPING[0];
            return {
                image: `${GITHUB_BASE_URL}imagenes/${asset.imageFile}`,
                marker: `${GITHUB_BASE_URL}markers/${asset.markerFile}`,
                model: `${GITHUB_BASE_URL}modelss/${asset.modelFile}`
            };
        }

        async function fetchWithCache(url, cache) {
            const cachedResponse = await cache.match(url);
            if (cachedResponse) return cachedResponse;
            
            try {
                const networkResponse = await fetch(url);

                if (networkResponse.ok) {
                    try {
                        await cache.put(url, networkResponse.clone());
                    } catch (e) {
                        console.warn(`No se pudo guardar el recurso en caché: ${url}`, e);
                    }
                }
                return networkResponse;
            } catch (e) {
                console.error(`Fallo en la petición fetch para: ${url}`, e);
                throw e; 
            }
        }

        async function clearCacheAndReload() {
            const loadButton = document.getElementById('load-assets-btn');
            const clearButton = document.getElementById('clear-cache-btn');
            const loadingText = document.getElementById('loading-text');
            const loadingStatusDiv = document.getElementById('loading-status');

            loadingStatusDiv.classList.remove('hidden');
            loadingText.textContent = 'Limpiando caché...';
            loadButton.disabled = true;
            clearButton.disabled = true;
            
            try {
                const keys = await caches.keys();
                await Promise.all(keys.map(key => {
                    if (key.startsWith('ar-color-cache')) {
                        return caches.delete(key);
                    }
                    return Promise.resolve();
                }));

                loadingText.innerHTML = '<span class="text-green-600">Caché limpiada. La página se recargará.</span>';
                
                setTimeout(() => window.location.reload(), 1500);

            } catch (error) {
                loadingText.innerHTML = `<span class="text-red-600">Error al limpiar la caché: ${error.message}</span>`;
                loadButton.disabled = false;
                clearButton.disabled = false;
            }
        }

        async function loadAndCacheAssets() {
            const loadingStatusDiv = document.getElementById('loading-status');
            const loadingText = document.getElementById('loading-text');
            const progressBar = document.getElementById('loading-progress-bar');
            const loadButton = document.getElementById('load-assets-btn');
            
            loadingStatusDiv.classList.remove('hidden');
            loadButton.disabled = true;
            progressBar.style.width = '0%';
            progressBar.classList.remove('bg-red-500');

            try {
                const cache = await caches.open(CACHE_NAME);
                const urls = getAssetUrls(); 

                const filesToLoad = Object.entries(urls);
                let loadedCount = 0;
                const tempAssets = {};

                for (const [key, url] of filesToLoad) {
                    loadingText.textContent = `Descargando ${key}...`;
                    const res = await fetchWithCache(url, cache);
                    if (!res.ok) throw new Error(`Fallo al descargar ${key} (Status: ${res.status})`);
                    const blob = await res.blob();
                    tempAssets[key] = URL.createObjectURL(blob);
                    loadedCount++;
                    progressBar.style.width = `${(loadedCount / filesToLoad.length) * 100}%`;
                }
                
                state.assets = tempAssets;

                loadingText.textContent = '¡Recursos cargados!';
                document.getElementById('marker-image').src = state.assets.image;
                document.getElementById('marker-image').classList.remove('hidden');
                setTimeout(() => navigateTo('ar'), 1000);

            } catch (error) {
                loadingText.innerHTML = `<span class="text-red-500 font-semibold">Error al descargar: ${error.message}. Revisa la conexión o intenta más tarde.</span>`;
                progressBar.style.width = '100%';
                progressBar.classList.add('bg-red-500');
                loadButton.disabled = false;
            }
        }

        async function initializeApp() {
            try {
                const cache = await caches.open(CACHE_NAME);
                const urls = getAssetUrls(); 
                
                const responses = await Promise.all(Object.values(urls).map(url => cache.match(url)));

                if (responses.every(res => res && res.ok)) {
                    const blobs = await Promise.all(responses.map(res => res.blob()));
                    state.assets = {
                        image: URL.createObjectURL(blobs[0]),
                        marker: URL.createObjectURL(blobs[1]),
                        model: URL.createObjectURL(blobs[2])
                    };
                    
                    document.getElementById('loader-welcome-text').textContent = 'Recursos encontrados en caché. ¡Listo para empezar!';
                    document.getElementById('marker-image').src = state.assets.image;
                    document.getElementById('marker-image').classList.remove('hidden');
                    navigateTo('ar');
                }
            } catch (error) {
                console.warn('Cache check failed:', error);
            }
        }

        function setupAndStartAR() {
            document.getElementById('start-ar-btn').disabled = true;
            document.getElementById('ar-preloader').classList.remove('hidden');
            const arSceneContainer = document.getElementById('ar-scene-container');
            arSceneContainer.innerHTML = ''; 

            const sceneHTML = `
                <a-scene id="ar-scene" embedded vr-mode-ui="enabled: false" device-orientation-permission-ui="enabled: false" mindar-image="imageTargetSrc: ${state.assets.marker}; autoStart: true; uiLoading: no; uiError: no; uiScanning: no;" color-space="sRGB" renderer="colorManagement: true, physicallyCorrectLights">
                    <a-assets timeout="30000">
                        <a-asset-item id="coloring-model" src="${state.assets.model}"></a-asset-item>
                    </a-assets>
                    <a-camera position="0 0 0" look-controls="enabled: false" fov="75"></a-camera>
                    <a-entity mindar-image-target="targetIndex: 0">
                        <a-gltf-model src="#coloring-model" position="0 -0.4 0" rotation="0 0 0" scale="0.8 0.8 0.8" ar-rotator texture-from-video></a-gltf-model>
                    </a-entity>
                </a-scene>`;
            arSceneContainer.innerHTML = sceneHTML;

            const sceneEl = document.getElementById('ar-scene');
            
            sceneEl.addEventListener('arReady', () => {
                document.getElementById('ar-preloader').classList.add('hidden');
                document.documentElement.classList.add('ar-active');
                document.body.classList.add('ar-active');
                document.getElementById('app').classList.add('ar-fullscreen');
                arSceneContainer.classList.add('ar-active');
                document.getElementById('ar-ui-container').classList.add('hidden');
                document.getElementById('ar-active-controls').classList.remove('hidden');
                document.getElementById('scanning-ui').classList.remove('hidden');
                state.isArActive = true;
            });
            sceneEl.addEventListener('targetFound', () => document.getElementById('scanning-ui').classList.add('hidden'));
            sceneEl.addEventListener('targetLost', () => document.getElementById('scanning-ui').classList.remove('hidden'));
        }

        function stopAR() {
            const arSceneContainer = document.getElementById('ar-scene-container');
            const sceneEl = arSceneContainer.querySelector('a-scene');
            if (sceneEl && sceneEl.systems['mindar-image-system']) { 
                sceneEl.systems['mindar-image-system'].stop();
                if (sceneEl.parentNode) sceneEl.parentNode.removeChild(sceneEl);
            }
            arSceneContainer.innerHTML = '';
            
            document.documentElement.classList.remove('ar-active');
            document.body.classList.remove('ar-active');
            document.getElementById('app').classList.remove('ar-fullscreen');
            document.getElementById('ar-ui-container').classList.remove('hidden');
            document.getElementById('ar-active-controls').classList.add('hidden');
            document.getElementById('scanning-ui').classList.add('hidden');                               
            state.isArActive = false;
            document.getElementById('start-ar-btn').disabled = false;
        }               

        document.getElementById('load-assets-btn').addEventListener('click', loadAndCacheAssets);
        document.getElementById('clear-cache-btn').addEventListener('click', clearCacheAndReload);
        document.getElementById('start-ar-btn').addEventListener('click', setupAndStartAR);
        document.getElementById('stop-ar-btn').addEventListener('click', stopAR);

        initializeApp();
    });
    </script>
</body>
</html>





